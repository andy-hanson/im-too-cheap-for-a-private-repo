package n

import u.*
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Type

interface N : HasSexpr {
	//val loc: Loc?
}

class Module(
	/** Logical path, e.g. "a/b" */
	val path: Path,
	/** Actual resolved path, e.g. "a/b.nz" or "a/b/main.nz" */
	//TODO: just remember 'isMain', and get this from the logical path!
	val fullPath: Path,
	val source: String) : N {

	val lineColumnGetter = LineColumnGetter(source)

	var imports: Arr<Module> by Late()
	var klass: Klass by Late()

	val loc
		get() = Loc(0, source.length)

	val name: Sym
		get() = klass.name

	override fun toSexpr(): Sexpr =
		sexpr("Module", sexpr("path", path), sexpr("imports", imports), klass)
}

sealed class Ty : Member() {
	// This should be available at initialization.
	abstract val javaTypeName: String
	abstract val javaTypeDescriptor: String

	// This may be generated by codegen (unavailable before).
	abstract val javaType: Class<*>

	abstract fun show(): String

	override fun toString() = show()
}

//Either a Klass or a BuiltinClass
sealed class ClassLike : Ty() {
	abstract fun getMember(name: Sym): Member?
	abstract val jClass: Class<*>

	override val javaType
		get() = jClass
}

class BuiltinClass(override val name: Sym, override val jClass: Class<*>) : ClassLike() {
	var members: Lookup<Sym, Member> by Late()

	//TODO: have a source file for builtins
	override val loc: Loc
		get() = TODO()

	override val javaTypeName =
		jClass.name
	override val javaTypeDescriptor =
		Type.getDescriptor(jClass)

	override fun getMember(name: Sym) =
		members[name]

	override fun show() =
		name.str

	override fun toSexpr() =
		sexpr("Builtin", name)
}

class Klass(override val loc: Loc, override val name: Sym) : ClassLike() {
	var head: Head by Late()
	private var membersMap: Lookup<Sym, Member> by Late()
	override var jClass: Class<*> by Late()
	var jClassBytes: ByteArray by Late()

	fun setMembers(members: Lookup<Sym, Member>) { membersMap = members }

	override val javaTypeName = escapeName(name)
	override val javaTypeDescriptor =
		"L$javaTypeName;"

	override fun show() = name.str

	override fun getMember(name: Sym) =
		membersMap[name]

	val members: Iterable<Member>
		get() = membersMap.values()

	val methods: Iterable<MethodWithBody>
		get() = members.filterIsInstance<MethodWithBody>()

	override fun toSexpr() = sexpr("Klass") {
		s(sexpr("name", name))
		s(sexpr("head", head))
		for (member in members) {
			when (member) {
				is Slot -> {} //already done in head
				is NzMethod -> {
					s(member)
				}
			}
		}
	}

	//TODO: collect data: isType, isGeneric
	sealed class Head : HasSexpr {
		//Note: vars will also be stored in the 'members' table.
		data class Slots(val loc: Loc, val slots: Arr<Slot>) : Head() {
			override fun toSexpr() =
				sexpr(slots)
		}
	}
}

sealed class Member : N {
	abstract val name: Sym
	abstract val loc: Loc
}
sealed class NzMethod(val klass: ClassLike, override val loc: Loc, val isStatic: Bool, val returnTy: Ty, override val name: Sym, val parameters: Arr<Parameter>) : Member() {
	val arity
		get() = parameters.size

	// For builtins, we assert that this is true.
	val javaName = escapeName(name)

	override fun toSexpr(): Sexpr =
		sexpr(if (isStatic) "fun" else "def", returnTy, name, sexpr(parameters))

	class Parameter(val loc: Loc, val ty: Ty, val name: Sym) : HasSexpr {
		override fun toSexpr(): Sexpr =
			sexprTuple(ty, name)
	}
}
class BuiltinMethod(klass: ClassLike, loc: Loc, isStatic: Bool, returnTy: Ty, name: Sym, parameters: Arr<Parameter>) : NzMethod(klass, loc, isStatic, returnTy, name, parameters)
class MethodWithBody(klass: ClassLike, loc: Loc, isStatic: Bool, returnTy: Ty, name: Sym, parameters: Arr<Parameter>) : NzMethod(klass, loc, isStatic, returnTy, name, parameters) {
	var body: Expr by Late()
}


data class Slot(val klass: ClassLike, override val loc: Loc, val mutable: Bool, val ty: Ty, override val name: Sym) : Member() {
	override fun toSexpr() =
		sexpr(if (mutable) "var" else "val", ty, name)

	val javaName = escapeName(name)
}


sealed class Expr : HasSexpr {
	abstract val loc: Loc
	abstract val ty: Ty
}
sealed class Pattern : HasSexpr {
	/** A `_` pattern. */
	class Ignore(val loc: Loc) : Pattern() {
		override fun toSexpr() =
			sexpr("Ignore")
	}
	class Single(val loc: Loc, val ty: Ty, val name: Sym) : Pattern() {
		override fun toSexpr() =
			sexprTuple(ty, name)
	}
	class Destruct(val loc: Loc, val destructedInto: Arr<Pattern>) : Pattern() {
		override fun toSexpr() =
			sexpr(destructedInto)
	}
}

sealed class Access : Expr() {
	abstract val name: Sym

	data class Parameter(override val loc: Loc, val param: NzMethod.Parameter) : Access() {
		override val ty
			get() = param.ty
		override val name
			get() = param.name

		override fun toSexpr() =
			sexpr("Access", param)
	}
	data class Local(override val loc: Loc, val local: Pattern.Single) : Access() {
		override val ty
			get() = local.ty
		override val name
			get() = local.name

		override fun toSexpr() =
			sexpr("Access", local)
	}
}

data class Let(override val loc: Loc, val assigned: Pattern, val value: Expr, val then: Expr): Expr() {
	override val ty
		get() = then.ty

	override fun toSexpr() = TODO()
}
data class Seq(override val loc: Loc, val action: Expr, val then: Expr) : Expr() {
	override val ty
		get() = then.ty

	override fun toSexpr() = TODO()
}


data class MethodCall(override val loc: Loc, val target: Expr, val method: NzMethod, val args: Arr<Expr>) : Expr() {
	init {
		assert(!method.isStatic)
	}

	override val ty
		get() = method.returnTy

	override fun toSexpr() = TODO()
}

data class GetSlot(override val loc: Loc, val target: Expr, val slot: Slot) : Expr() {
	init {
		assert(!slot.mutable)
	}

	override val ty
		get() = slot.ty

	override fun toSexpr() = TODO()
}

/*class GetProperty(override val loc: Loc, val target: Expr, val name: Sym) : Expr() {
	override fun ty(): Ty {
		val x = target.ty()
		TODO()
	}
}*/

val operatorEscapes = mapOf(
	"+" to "_add",
	"-" to "_sub",
	"*" to "_mul",
	"/" to "_div",
	"^" to "_pow"
).mapKeys { it.key.sym }
val operatorEscapesReverse = operatorEscapes.reverse()

//move?
fun escapeName(name: Sym): String {
	val x = operatorEscapes[name]
	if (x != null)
		return x

	assert(Regex("^[a-zA-Z]+$").matches(name.str)) //TODO: better escaping
	return name.str
}
fun unescapeName(name: String): Sym =
	operatorEscapesReverse[name] ?: name.sym







//TODO
//This may be a *non-generic* Class, or an instantiation of a generic class.
//Function type literals (`Bool -> Int`) should compile to instantiations of the Fun class.
//sealed class Ty

//class GenInst(val klass: NzClass, val args: Arr<Ty>) : Ty() {
//	override fun javaTypeName() = klass.javaTypeName()
//	override fun javaType() = klass.javaType()
//}

/*
sealed class GenVar : Ty() {
	override fun javaType() = TODO() //???

	class Builtin(val name: Sym) : GenVar() {
		override fun javaTypeName() = name.str
	}
	class Declared(val origin: CodeOrigin) : GenVar() {
		override fun javaTypeName() = origin.name.str
	}
}
*/

/**
Origin for something that was explicitly written down
(as opposed to builtin or created from generic application)
 */
class CodeOrigin(val module: Module, val loc: Loc, val name: Sym)
