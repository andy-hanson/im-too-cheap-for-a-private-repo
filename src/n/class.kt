package n

import u.*
import org.objectweb.asm.Opcodes

class Module(
	/** Logical path, e.g. "a/b" */
	val path: Path,
	/** Actual resolved path, e.g. "a/b.nz" or "a/b/main.nz" */
	val fullPath: Path,
	val klass: NzClass) {

	val imports: Arr<Module> by Late()
}

sealed class Ty {
	// This should be available at initialization.
	abstract fun javaTypeName(): String

	// This may be generated by codegen (unavailable before).
	abstract fun javaType(): Class<*>

	open fun returnOpcode(): Int {
		return Opcodes.ARETURN
	}
}

class NzClass(val name: Sym, val head: Head, val members: Lookup<Sym, Member>) : Ty() {
	//typeParameters: Arr<T>?
	//slotsOrEnum

	//TODO: collect data: isType, isGeneric
	sealed class Head {
		data class Record(val loc: Loc, val vars: Arr<Var>) : Head() {
			data class Var(val loc: Loc, val mutable: Bool, val ty: Ty, val name: Sym) {
			}
		}
	}
}

sealed class Member
class Method(val isStatic: Bool, val returnTy: Ty, val parameters: Arr<Parameter>) : Member() {
	val body: Expr by Late()

	class Parameter(val ty: Ty, val name: Sym)
}


sealed class Expr {
	abstract val loc: Loc
}
sealed class Pattern {
	/** A `_` pattern. */
	class Ignore(val loc: Loc) : Pattern()
	class Single(val ty: Ty, val name: Sym) : Pattern()
	class Destruct(val loc: Loc, val destructedInto: Arr<Pattern>) : Pattern()
}
class Let(override val loc: Loc, val assigned: Pattern, val value: Expr, val then: Expr): Expr()
class Seq(override val loc: Loc, val action: Expr, val then: Expr) : Expr()
//???
class Value(override val loc: Loc, val value: Any) : Expr()
class Call(override val loc: Loc, val target: Expr, val arguments: Arr<Expr>) : Expr()
class GetProperty(override val loc: Loc, val target: Expr, val name: Sym) : Expr()

//TODO
//This may be a *non-generic* Class, or an instantiation of a generic class.
//Function type literals (`Bool -> Int`) should compile to instantiations of the Fun class.
//sealed class Ty

class GenInst(val klass: NzClass, val args: Arr<Ty>)

sealed class Primitive(nameStr: String) : Ty() {
	val name: Sym = nameStr.sym

	object Bool : Primitive("Bool") {
		override fun javaTypeName() = "Z"
		override fun javaType() = java.lang.Boolean.TYPE
		override fun returnOpcode() = Opcodes.IRETURN
	}
	object Float : Primitive("Float") {
		override fun javaTypeName() = "D"
		override fun javaType() = java.lang.Double.TYPE
		override fun returnOpcode() = Opcodes.DRETURN
	}
	object Int : Primitive("Int") {
		override fun javaTypeName() = "I"
		override fun javaType() = java.lang.Integer.TYPE
		override fun returnOpcode() = Opcodes.IRETURN
	}
	object Str : Primitive("String") {
		override fun javaTypeName() = "java/lang/String"
		override fun javaType() = String::class.java
	}
	object Void : Primitive("Void") {
		override fun javaTypeName() = "V"
		// Void should never be used as a parameter type.
		override fun javaType() = throw NotImplementedError()
		override fun returnOpcode() = Opcodes.RETURN
	}
}

sealed class GenVar : Ty() {
	override fun javaType() = TODO() //???

	class Builtin(val name: Sym) : GenVar() {
		override fun javaTypeName() = name.str
	}
	class Declared(val origin: CodeOrigin) : GenVar() {
		override fun javaTypeName() = origin.name.str
	}
}

/**
Origin for something that was explicitly written down
(as opposed to builtin or created from generic application)
 */
class CodeOrigin(val module: Module, val loc: Loc, val name: Sym)
