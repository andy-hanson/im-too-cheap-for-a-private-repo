package n

import u.*
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Type
import Builtins.NzInt
import Builtins.NzFloat
import Builtins.NzString

interface N : HasSexpr {
	//val loc: Loc?
}

class Module(
	/** Logical path, e.g. "a/b" */
	val path: Path,
	/** Actual resolved path, e.g. "a/b.nz" or "a/b/main.nz" */
	//TODO: just remember 'isMain', and get this from the logical path!
	val fullPath: Path,
	val source: String) : N {

	val lineColumnGetter = LineColumnGetter(source)

	var imports: Arr<Module> by Late()
	var klass: Klass by Late()

	val importsAreResolved
		get() = (this::imports.getDelegate() as Late<*>).isSet

	val loc
		get() = Loc(0, source.length)

	val name: Sym
		get() = klass.name

	override fun toSexpr(): Sexpr =
		sexpr("Module", sexpr("path", path), sexpr("imports", imports), klass)
}

sealed class Ty : Member() {
	// This should be available at initialization.
	abstract val javaTypeName: String
	abstract val javaTypeDescriptor: String

	// This may be generated by codegen (unavailable before).
	abstract val javaType: Class<*>

	abstract fun show(): String

	override fun toString() = show()
}

//Either a Klass or a BuiltinClass
sealed class ClassLike : Ty() {
	abstract operator fun get(name: Sym): Member?
	abstract val jClass: Class<*>

	override val javaType
		get() = jClass
}

class BuiltinClass private constructor(override val name: Sym, override val jClass: Class<*>) : ClassLike() {
	companion object {
		private val mp = hashMapOf<Class<*>, BuiltinClass>()
		operator fun invoke(name: Sym, jClass: Class<*>): BuiltinClass {
			val old = mp.get(jClass)
			if (old != null) {
				assert(old.name == name)
				return old
			}
			val x = BuiltinClass(name, jClass)
			mp[jClass] = x
			return x
		}
	}

	var members: Map<Sym, Member> by Late()

	//TODO: have a source file for builtins
	override val loc: Loc
		get() = TODO()

	override val javaTypeName =
		jClass.name
	override val javaTypeDescriptor =
		Type.getDescriptor(jClass)

	override fun get(name: Sym) =
		members[name]

	override fun show() =
		name.str

	override fun toSexpr() =
		sexpr("Builtin", name)
}

class Klass(override val loc: Loc, override val name: Sym) : ClassLike() {
	var head: Head by Late()
	private var membersMap: Map<Sym, Member> by Late()
	override var jClass: Class<*> by Late()
	var jClassBytes: ByteArray by Late()

	fun setMembers(members: Map<Sym, Member>) { membersMap = members }

	override val javaTypeName = escapeName(name)
	override val javaTypeDescriptor =
		"L$javaTypeName;"

	override fun show() = name.str

	override fun get(name: Sym) =
		membersMap[name]

	val members: Iterable<Member>
		get() = membersMap.valuesIter()

	val methods: Iterable<MethodWithBody>
		get() = members.filterIsInstance<MethodWithBody>()

	override fun toSexpr() = sexpr("Klass") {
		s(sexpr("name", name))
		s(sexpr("head", head))
		for (member in members) {
			when (member) {
				is Slot -> {} //already done in head
				is NzMethod -> {
					s(member)
				}
			}
		}
	}

	//TODO: collect data: isType, isGeneric
	sealed class Head : HasSexpr {
		//Note: vars will also be stored in the 'members' table.
		data class Slots(val loc: Loc, val slots: Arr<Slot>) : Head() {
			override fun toSexpr() =
				sexpr(slots)
		}
	}
}

sealed class Member : N {
	abstract val name: Sym
	abstract val loc: Loc
}
sealed class NzMethod(val klass: ClassLike, override val loc: Loc, val isStatic: Boolean, val returnTy: Ty, override val name: Sym, val parameters: Arr<Parameter>) : Member() {
	val arity
		get() = parameters.size

	// For builtins, we assert that this is true.
	val javaName = escapeName(name)

	override fun toSexpr(): Sexpr =
		sexpr(if (isStatic) "fun" else "def", returnTy, name, sexpr(parameters))

	class Parameter(val loc: Loc, val ty: Ty, val name: Sym) : HasSexpr {
		override fun toSexpr(): Sexpr =
			sexprTuple(ty, name)
	}
}
class BuiltinMethod(klass: ClassLike, loc: Loc, isStatic: Boolean, returnTy: Ty, name: Sym, parameters: Arr<Parameter>) : NzMethod(klass, loc, isStatic, returnTy, name, parameters)
class MethodWithBody(klass: ClassLike, loc: Loc, isStatic: Boolean, returnTy: Ty, name: Sym, parameters: Arr<Parameter>) : NzMethod(klass, loc, isStatic, returnTy, name, parameters) {
	var body: Expr by Late()
}


data class Slot(val klass: ClassLike, override val loc: Loc, val mutable: Boolean, val ty: Ty, override val name: Sym) : Member() {
	override fun toSexpr() =
		sexpr(if (mutable) "var" else "val", ty, name)

	val javaName = escapeName(name)
}


sealed class Expr : HasSexpr {
	abstract val loc: Loc
	abstract val ty: Ty
}
sealed class Pattern : HasSexpr {
	/** A `_` pattern. */
	class Ignore(val loc: Loc) : Pattern() {
		override fun toSexpr() =
			sexpr("Ignore")
	}
	class Single(val loc: Loc, val ty: Ty, val name: Sym) : Pattern() {
		override fun toSexpr() =
			sexprTuple(ty, name)
	}
	class Destruct(val loc: Loc, val destructedInto: Arr<Pattern>) : Pattern() {
		override fun toSexpr() =
			sexpr(destructedInto)
	}
}

sealed class Access : Expr() {
	abstract val name: Sym

	override fun toSexpr() =
		sexpr("Access", name)

	data class Parameter(override val loc: Loc, val param: NzMethod.Parameter) : Access() {
		override val ty
			get() = param.ty
		override val name
			get() = param.name
	}

	data class Local(override val loc: Loc, val local: Pattern.Single) : Access() {
		override val ty
			get() = local.ty
		override val name
			get() = local.name
	}
}

data class Let(override val loc: Loc, val assigned: Pattern, val value: Expr, val then: Expr): Expr() {
	override val ty
		get() = then.ty

	override fun toSexpr() = TODO()
}
data class Seq(override val loc: Loc, val action: Expr, val then: Expr) : Expr() {
	override val ty
		get() = then.ty

	override fun toSexpr() = TODO()
}

sealed class LiteralValue : HasSexpr {
	abstract val ty: n.Ty

	data class Int(val value: kotlin.Int) : LiteralValue() {
		override val ty
			get() = NzInt.ty()

		override fun toSexpr() =
				Sexpr.N(value)
	}

	data class Float(val value: Double): LiteralValue() {
		override val ty
			get() = NzFloat.ty()

		override fun toSexpr() =
				Sexpr.F(value)
	}

	data class Str(val value: String) : LiteralValue() {
		override val ty
			get() = NzString.ty()

		override fun toSexpr() =
				Sexpr.Str(value)
	}
}

data class Literal(override val loc: Loc, val value: LiteralValue) : Expr() {
	override val ty
		get() = value.ty

	override fun toSexpr() = TODO()
}

data class StaticMethodCall(override val loc: Loc, val method: NzMethod, val args: Arr<Expr>) : Expr() {
	init {
		assert(method.isStatic)
	}

	override val ty
		get() = method.returnTy

	override fun toSexpr() = TODO()
}

data class MethodCall(override val loc: Loc, val target: Expr, val method: NzMethod, val args: Arr<Expr>) : Expr() {
	init {
		assert(!method.isStatic)
	}

	override val ty
		get() = method.returnTy

	override fun toSexpr() = TODO()
}

data class GetSlot(override val loc: Loc, val target: Expr, val slot: Slot) : Expr() {
	init {
		assert(!slot.mutable)
	}

	override val ty
		get() = slot.ty

	override fun toSexpr() = TODO()
}

/*class GetProperty(override val loc: Loc, val target: Expr, val name: Sym) : Expr() {
	override fun ty(): Ty {
		val x = target.ty()
		TODO()
	}
}*/

val operatorEscapes = mapOf(
	"+" to "_add",
	"-" to "_sub",
	"*" to "_mul",
	"/" to "_div",
	"^" to "_pow"
).mapKeys { it.key.sym }
val operatorEscapesReverse = operatorEscapes.reverse()

//move?
fun escapeName(name: Sym): String {
	val x = operatorEscapes[name]
	if (x != null)
		return x

	assert(Regex("^[a-zA-Z]+$").matches(name.str)) //TODO: better escaping
	return name.str
}
fun unescapeName(name: String): Sym =
	operatorEscapesReverse[name] ?: name.sym







//TODO
//This may be a *non-generic* Class, or an instantiation of a generic class.
//Function type literals (`Bool -> Int`) should compile to instantiations of the Fun class.
//sealed class Ty

//class GenInst(val klass: NzClass, val args: Arr<Ty>) : Ty() {
//	override fun javaTypeName() = klass.javaTypeName()
//	override fun javaType() = klass.javaType()
//}

/*
sealed class GenVar : Ty() {
	override fun javaType() = TODO() //???

	class Builtin(val name: Sym) : GenVar() {
		override fun javaTypeName() = name.str
	}
	class Declared(val origin: CodeOrigin) : GenVar() {
		override fun javaTypeName() = origin.name.str
	}
}
*/

/**
Origin for something that was explicitly written down
(as opposed to builtin or created from generic application)
 */
class CodeOrigin(val module: Module, val loc: Loc, val name: Sym)
